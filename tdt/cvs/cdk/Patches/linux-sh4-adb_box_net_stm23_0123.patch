diff -Nur linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/smc91x.c linux-sh4/drivers/net/smc91x.c
--- linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/smc91x.c	2011-05-27 18:30:18.000000000 +0200
+++ linux-sh4/drivers/net/smc91x.c	2011-05-01 15:50:08.000000000 +0200
@@ -1,64 +1,13 @@
 /*
  * smc91x.c
- * This is a driver for SMSC's 91C9x/91C1xx single-chip Ethernet devices.
- *
- * Copyright (C) 1996 by Erik Stahlman
- * Copyright (C) 2001 Standard Microsystems Corporation
- *	Developed by Simple Network Magic Corporation
- * Copyright (C) 2003 Monta Vista Software, Inc.
- *	Unified SMC91x driver by Nicolas Pitre
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Arguments:
  * 	io	= for the base address
  *	irq	= for the IRQ
  *	nowait	= 0 for normal wait states, 1 eliminates additional wait states
  *
- * original author:
- * 	Erik Stahlman <erik@vt.edu>
- *
- * hardware multicast code:
- *    Peter Cammaert <pc@denkart.be>
- *
- * contributors:
- * 	Daris A Nevil <dnevil@snmc.com>
- *      Nicolas Pitre <nico@cam.org>
- *	Russell King <rmk@arm.linux.org.uk>
- *
- * History:
- *   08/20/00  Arnaldo Melo       fix kfree(skb) in smc_hardware_send_packet
- *   12/15/00  Christian Jullien  fix "Warning: kfree_skb on hard IRQ"
- *   03/16/01  Daris A Nevil      modified smc9194.c for use with LAN91C111
- *   08/22/01  Scott Anderson     merge changes from smc9194 to smc91111
- *   08/21/01  Pramod B Bhardwaj  added support for RevB of LAN91C111
- *   12/20/01  Jeff Sutherland    initial port to Xscale PXA with DMA support
- *   04/07/03  Nicolas Pitre      unified SMC91x driver, killed irq races,
- *                                more bus abstraction, big cleanup, etc.
- *   29/09/03  Russell King       - add driver model support
- *                                - ethtool support
- *                                - convert to use generic MII interface
- *                                - add link up/down notification
- *                                - don't try to handle full negotiation in
- *                                  smc_phy_configure
- *                                - clean up (and fix stack overrun) in PHY
- *                                  MII read/write functions
- *   22/09/04  Nicolas Pitre      big update (see commit log for details)
  */
-static const char version[] =
-	"smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <nico@cam.org>\n";
+static const char version[] = "SMC91113\n";
 
 /* Debugging level */
 #ifndef SMC_DEBUG
@@ -66,6 +15,7 @@
 #endif
 
 
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -93,29 +43,29 @@
 #ifdef CONFIG_ISA
 /*
  * the LAN91C111 can be at any of the following port addresses.  To change,
- * for a slightly different card, you can add it to the array.  Keep in
- * mind that the array must end in zero.
- */
-static unsigned int smc_portlist[] __initdata = {
+  * for a slightly different card, you can add it to the array.  Keep in
+   * mind that the array must end in zero.
+    */
+    static unsigned int smc_portlist[] __initdata = {
 	0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
-	0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
-};
-
-#ifndef SMC_IOADDR
-# define SMC_IOADDR		-1
-#endif
-static unsigned long io = SMC_IOADDR;
-module_param(io, ulong, 0400);
-MODULE_PARM_DESC(io, "I/O base address");
-
-#ifndef SMC_IRQ
-# define SMC_IRQ		-1
-#endif
-static int irq = SMC_IRQ;
-module_param(irq, int, 0400);
-MODULE_PARM_DESC(irq, "IRQ number");
-
-#endif  /* CONFIG_ISA */
+	    0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
+	    };
+	    
+	    #ifndef SMC_IOADDR
+	    # define SMC_IOADDR		-1
+	    #endif
+	    static unsigned long io = SMC_IOADDR;
+	    module_param(io, ulong, 0400);
+	    MODULE_PARM_DESC(io, "I/O base address");
+	    
+	    #ifndef SMC_IRQ
+	    # define SMC_IRQ		-1
+	    #endif
+	    static int irq = SMC_IRQ;
+	    module_param(irq, int, 0400);
+	    MODULE_PARM_DESC(irq, "IRQ number");
+	    
+	    #endif  /* CONFIG_ISA */
 
 #ifndef SMC_NOWAIT
 # define SMC_NOWAIT		0
@@ -125,14 +75,17 @@
 MODULE_PARM_DESC(nowait, "set to 1 for no wait state");
 
 /*
+ * MAC Address is stored in FLASH
+ */ 
+static unsigned long macioaddr = 0xA002020E;
+
+/*
  * Transmit timeout, default 5 seconds.
  */
-static int watchdog = 1000;
+static int watchdog = 5000;
 module_param(watchdog, int, 0400);
 MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
 
-MODULE_LICENSE("GPL");
-
 /*
  * The internal workings of the driver.  If you are changing anything
  * here with the SMC stuff, you should have the datasheet and know
@@ -140,6 +93,7 @@
  */
 #define CARDNAME "smc91x"
 
+
 /*
  * Use power-down feature of the chip
  */
@@ -154,7 +108,7 @@
 
 /*
  * The maximum number of processing loops allowed for each call to the
- * IRQ handler.
+ * IRQ handler.  
  */
 #define MAX_IRQ_LOOPS		8
 
@@ -210,7 +164,6 @@
 
 	/* work queue */
 	struct work_struct phy_configure;
-	struct net_device *dev;
 	int	work_pending;
 
 	spinlock_t lock;
@@ -308,6 +261,9 @@
 	}								\
 } while (0)
 
+// d-mon: nbox' hardcoded MAC
+unsigned char hw_mac[6] = {0,3,0x91,0x11,0x22,0x33 };   
+ 
 
 /*
  * this does a soft reset on the device
@@ -322,12 +278,12 @@
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
 	/* Disable all interrupts, block TX tasklet */
-	spin_lock_irq(&lp->lock);
+	spin_lock(&lp->lock);
 	SMC_SELECT_BANK(2);
 	SMC_SET_INT_MASK(0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock(&lp->lock);
 
 	/* free any pending tx skb */
 	if (pending_skb) {
@@ -342,6 +298,10 @@
 	 */
 	SMC_SELECT_BANK(0);
 	SMC_SET_RCR(RCR_SOFTRST);
+	
+	msleep(100); // d-mon
+	SMC_SET_RCR(RCR_CLEAR);
+	msleep(60);
 
 	/*
 	 * Setup the Configuration Register
@@ -357,8 +317,7 @@
 	 * can't handle it then there will be no recovery except for
 	 * a hard reset or power cycle
 	 */
-	if (nowait)
-		cfg |= CONFIG_NO_WAIT;
+	if (nowait) cfg |= CONFIG_NO_WAIT;
 
 	/*
 	 * Release from possible power-down state
@@ -380,8 +339,8 @@
 
 	/* Disable transmit and receive functionality */
 	SMC_SELECT_BANK(0);
-	SMC_SET_RCR(RCR_CLEAR);
 	SMC_SET_TCR(TCR_CLEAR);
+	udelay(5); // d-mon
 
 	SMC_SELECT_BANK(1);
 	ctl = SMC_GET_CTL() | CTL_LE_ENABLE;
@@ -395,10 +354,12 @@
 		ctl |= CTL_AUTO_RELEASE;
 	else
 		ctl &= ~CTL_AUTO_RELEASE;
+
 	SMC_SET_CTL(ctl);
 
 	/* Reset the MMU */
 	SMC_SELECT_BANK(2);
+	udelay(5); // d-mon
 	SMC_SET_MMU_CMD(MC_RESET);
 	SMC_WAIT_MMU_BUSY();
 }
@@ -412,20 +373,23 @@
 	void __iomem *ioaddr = lp->base;
 	int mask;
 
-	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+	DBG(2, "%s: %s  -- baseioaddr = 0x%08Xu\n", dev->name, __FUNCTION__, (unsigned long)lp->base);
 
 	/* see the header file for options in TCR/RCR DEFAULT */
 	SMC_SELECT_BANK(0);
 	SMC_SET_TCR(lp->tcr_cur_mode);
+	udelay(10);
 	SMC_SET_RCR(lp->rcr_cur_mode);
+	udelay(10);
 
 	SMC_SELECT_BANK(1);
 	SMC_SET_MAC_ADDR(dev->dev_addr);
 
 	/* now, enable interrupts */
-	mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
+	//mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
+	mask = IM_ERCV_INT|IM_ALLOC_INT|IM_RCV_INT | IM_MDINT; // d-mon
 	if (lp->version >= (CHIP_91100 << 4))
-		mask |= IM_MDINT;
+		mask = IM_MDINT | IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT;
 	SMC_SELECT_BANK(2);
 	SMC_SET_INT_MASK(mask);
 
@@ -449,12 +413,12 @@
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
 
 	/* no more interrupts for me */
-	spin_lock_irq(&lp->lock);
+	spin_lock(&lp->lock);
 	SMC_SELECT_BANK(2);
 	SMC_SET_INT_MASK(0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
-	spin_unlock_irq(&lp->lock);
+	spin_unlock(&lp->lock);
 	if (pending_skb)
 		dev_kfree_skb(pending_skb);
 
@@ -568,6 +532,7 @@
 		PRINT_PKT(data, packet_len - 4);
 
 		dev->last_rx = jiffies;
+		skb->dev = dev;
 		skb->protocol = eth_type_trans(skb, dev);
 		netif_rx(skb);
 		lp->stats.rx_packets++;
@@ -765,7 +730,7 @@
 		/*
 		 * Allocation succeeded: push packet to the chip's own memory
 		 * immediately.
-		 */
+		 */  
 		smc_hardware_send_pkt((unsigned long)dev);
 	}
 
@@ -904,7 +869,7 @@
 	/* Return to idle state */
 	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
-	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
+	DBG(4, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
 
 	SMC_SELECT_BANK(2);
@@ -931,7 +896,7 @@
 	/* Return to idle state */
 	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
-	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
+	DBG(4, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
 
 	SMC_SELECT_BANK(2);
@@ -1037,7 +1002,7 @@
 
 	for (timeout = 2; timeout; timeout--) {
 		spin_unlock_irq(&lp->lock);
-		msleep(50);
+		msleep(100);
 		spin_lock_irq(&lp->lock);
 
 		bmcr = smc_phy_read(dev, phy, MII_BMCR);
@@ -1080,59 +1045,6 @@
 }
 
 /*
- * smc_phy_powerup - powerup phy
- * @dev: net device
- *
- * Restore the device in normal power mode.
- */
-static void smc_phy_powerup(struct net_device *dev)
-{
-	struct smc_local *lp = netdev_priv(dev);
-	unsigned int bmcr;
-	int phy = lp->mii.phy_id;
-	void __iomem *ioaddr = lp->base;
-
-	if (lp->phy_type == 0)
-		return;
-
-	bmcr = smc_phy_read(dev, phy, MII_BMCR);
-	DBG(2, "smc_phy_powerup: PHY Ctrl Reg: 0x%x\n", bmcr);
-
-	/* Write the PDN bit in PHY MI register 0 */
-	bmcr &= ~BMCR_PDOWN;
-	smc_phy_write(dev, phy, MII_BMCR, bmcr);
-
-	/* PHY should be in isolation mode */
-	while (!(bmcr = smc_phy_read(dev, phy, MII_BMCR) & BMCR_ISOLATE)){}
-
-	/* Clear MII_DIS bit.*/
-	bmcr &= ~BMCR_ISOLATE;
-	smc_phy_write(dev, phy, MII_BMCR, bmcr);
-
-	/* Wait 500ms for the PHY in order to restore normal operation mode */
-	msleep(500);
-
-	/* Reconfigure the device caps */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RPC(lp->rpc_cur_mode);
-
-	if (lp->mii.force_media) {
-		smc_phy_fixed(dev);
-		goto smc_phy_powerup_exit;
-	}
-
-	smc_phy_read(dev, phy, MII_ADVERTISE);
-
-	bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
-	smc_phy_write(dev, phy, MII_BMCR, bmcr);
-
-smc_phy_powerup_exit:
-	SMC_SELECT_BANK(2);
-	lp->work_pending = 0;
-	return;
-}
-
-/*
  * smc_phy_check_media - check the media status and adjust TCR
  * @dev: net device
  * @init: set true for initialisation
@@ -1144,8 +1056,40 @@
 {
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
-
+/*	int timeout = 20;
+	unsigned short status = 0;
+	
+	while (timeout--) {
+		status = smc_phy_read(dev, lp->mii.phy_id, MII_BMSR);
+		//printk("+++ SMC: PHY status=%04X\n",status);
+		if (status & 0x0020) {
+			// auto-negotiate complete 
+			break;
+		}
+		spin_unlock_irq(&lp->lock);
+		msleep(200);
+		spin_lock_irq(&lp->lock);
+		// Restart auto-negotiation if remote fault 
+		if (status & 0x0010) {
+			printk ("+++ SMC: PHY remote fault detected\n\tPHY restarting auto-negotiation\n");
+
+			// Restart auto-negotiation 
+			smc_phy_write(dev, lp->mii.phy_id, MII_BMCR,
+						0x1000 |
+						0x0200 |
+						0x2000 |
+						0x0100);
+		}
+	}
+	if (timeout < 1) {
+		printk ("SMC: PHY auto-negotiate timed out\n");
+		return;
+	}
+*/
+	// DBG(3, "+++ %s:smc_phy_check_media()\n", dev->name);
+	
 	if (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {
+	
 		/* duplex state has changed */
 		if (lp->mii.full_duplex) {
 			lp->tcr_cur_mode |= TCR_SWFDUP;
@@ -1167,11 +1111,10 @@
  * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection
  * is controlled by the RPC SPEED and RPC DPLX bits.
  */
-static void smc_phy_configure(struct work_struct *work)
+static void smc_phy_configure(void *data)
 {
-	struct smc_local *lp =
-		container_of(work, struct smc_local, phy_configure);
-	struct net_device *dev = lp->dev;
+	struct net_device *dev = data;
+	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 	int phyaddr = lp->mii.phy_id;
 	int my_phy_caps; /* My PHY capabilities */
@@ -1197,13 +1140,18 @@
 	 * Enable PHY Interrupts (for register 18)
 	 * Interrupts listed here are disabled
 	 */
+	 smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
 	smc_phy_write(dev, phyaddr, PHY_MASK_REG,
 		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
 		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
 		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+	
+	smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
+	smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
 
 	/* Configure the Receive/Phy Control register */
 	SMC_SELECT_BANK(0);
+	// printk("+++ rpc_cur_mode: 0x%04X\n",lp->rpc_cur_mode);
 	SMC_SET_RPC(lp->rpc_cur_mode);
 
 	/* If the user requested no auto neg, then go set his request */
@@ -1338,8 +1286,9 @@
  * This is the main routine of the driver, to handle the device when
  * it needs some attention.
  */
-static irqreturn_t smc_interrupt(int irq, void *dev_id)
+static irqreturn_t smc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+
 	struct net_device *dev = dev_id;
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
@@ -1454,7 +1403,7 @@
 static void smc_poll_controller(struct net_device *dev)
 {
 	disable_irq(dev->irq);
-	smc_interrupt(dev->irq, dev);
+	smc_interrupt(dev->irq, dev, NULL);
 	enable_irq(dev->irq);
 }
 #endif
@@ -1611,8 +1560,7 @@
  *
  * Set up everything, reset the card, etc..
  */
-static int
-smc_open(struct net_device *dev)
+static int smc_open(struct net_device *dev)
 {
 	struct smc_local *lp = netdev_priv(dev);
 
@@ -1646,7 +1594,7 @@
 
 	/* Configure the PHY, initialize the link state */
 	if (lp->phy_type != 0)
-		smc_phy_configure(&lp->phy_configure);
+		smc_phy_configure(dev);
 	else {
 		spin_lock_irq(&lp->lock);
 		smc_10bt_check_media(dev, 1);
@@ -1680,6 +1628,34 @@
 	return 0;
 }
 
+
+/*
+d-mon: for debug only.
+Query interrupt status
+*/
+/*
+static void print_irp_stats(struct net_device *dev)
+{
+	
+	int phy18, status, mask, phy_status;
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = netdev_priv(dev);
+	int phyaddr = lp->mii.phy_id;
+
+	spin_lock(&lp->lock);
+	
+	status = SMC_GET_INT();
+	mask = SMC_GET_INT_MASK(); 
+	phy18 = smc_phy_read(dev, phyaddr, PHY_INT_REG);
+	phy_status = smc_phy_read(dev, phyaddr, MII_BMCR);
+	
+	spin_unlock(&lp->lock);
+  
+  printk(">>> SMC INT Status >>>\n\tSMC INT:%04X\n\tSMC MSK:%04X\n\tPHY INT:%04X\n\tPHY STA:%04X\n",
+  	status,mask,phy18,phy_status);
+	
+}*/
+
 /*
  * Get the current statistics.
  * This may be called with the card open or closed.
@@ -1689,6 +1665,7 @@
 	struct smc_local *lp = netdev_priv(dev);
 
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
+	//print_irp_stats(dev);
 
 	return &lp->stats;
 }
@@ -1696,8 +1673,7 @@
 /*
  * Ethtool support
  */
-static int
-smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int smc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
@@ -1730,8 +1706,7 @@
 	return ret;
 }
 
-static int
-smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int smc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	int ret;
@@ -1759,12 +1734,12 @@
 	return ret;
 }
 
-static void
-smc_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+static void smc_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 {
 	strncpy(info->driver, CARDNAME, sizeof(info->driver));
 	strncpy(info->version, version, sizeof(info->version));
-	strncpy(info->bus_info, dev->dev.parent->bus_id, sizeof(info->bus_info));
+	//strncpy(info->bus_info, dev->class_dev.dev->bus_id, sizeof(info->bus_info));
+	  strncpy(info->bus_info, dev->dev.parent->bus_id, sizeof(info->bus_info));
 }
 
 static int smc_ethtool_nwayreset(struct net_device *dev)
@@ -1837,7 +1812,6 @@
 			goto out;
 		}
 	} while (SMC_GET_CTL() & cmd);
-
 	if (! write) {
 		*val = SMC_inw(ioaddr, GP_REG);
 	}
@@ -1851,8 +1825,7 @@
 	return res;
 }
 
-static int smc_ethtool_geteeprom(struct net_device *dev,
-        struct ethtool_eeprom *eeprom, u8 *bytes)
+static int smc_ethtool_geteeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *bytes)
 {
 	int res;
 	u16 tmp;
@@ -1887,8 +1860,7 @@
 	return 0;
 }
 
-static int smc_ethtool_seteeprom(struct net_device *dev,
-	struct ethtool_eeprom *eeprom, u8 *bytes)
+static int smc_ethtool_seteeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *bytes)
 {
 	int res;
 	u16 tmp;
@@ -1927,7 +1899,7 @@
 	return 0;
 }
 
-static const struct ethtool_ops smc_ethtool_ops = {
+static struct ethtool_ops smc_ethtool_ops = {
 	.get_settings	= smc_ethtool_getsettings,
 	.set_settings	= smc_ethtool_setsettings,
 	.get_drvinfo	= smc_ethtool_getdrvinfo,
@@ -2030,8 +2002,9 @@
 {
 	struct smc_local *lp = netdev_priv(dev);
 	static int version_printed = 0;
-	int i, retval;
+	int i, j, retval;
 	unsigned int val, revision_register;
+	//unsigned char *macflash;
 	const char *version_string;
 
 	DBG(2, "%s: %s\n", CARDNAME, __FUNCTION__);
@@ -2041,9 +2014,7 @@
 	DBG(2, "%s: bank signature probe returned 0x%04x\n", CARDNAME, val);
 	if ((val & 0xFF00) != 0x3300) {
 		if ((val & 0xFF) == 0x33) {
-			printk(KERN_WARNING
-				"%s: Detected possible byte-swapped interface"
-				" at IOADDR %p\n", CARDNAME, ioaddr);
+			printk(KERN_WARNING "%s: Detected possible byte-swapped interface at IOADDR %p\n", CARDNAME, ioaddr);
 		}
 		retval = -ENODEV;
 		goto err_out;
@@ -2055,6 +2026,7 @@
 	 */
 	SMC_SELECT_BANK(0);
 	val = SMC_CURRENT_BANK();
+    DBG(2, "%s: val = %X\n", CARDNAME, val);
 	if ((val & 0xFF00) != 0x3300) {
 		retval = -ENODEV;
 		goto err_out;
@@ -2070,8 +2042,7 @@
 	val = SMC_GET_BASE();
 	val = ((val & 0x1F00) >> 3) << SMC_IO_SHIFT;
 	if (((unsigned int)ioaddr & (0x3e0 << SMC_IO_SHIFT)) != val) {
-		printk("%s: IOADDR %p doesn't match configuration (%x).\n",
-			CARDNAME, ioaddr, val);
+		printk("%s: IOADDR %p doesn't match configuration (%x).\n", CARDNAME, ioaddr, val);
 	}
 
 	/*
@@ -2082,12 +2053,12 @@
 	SMC_SELECT_BANK(3);
 	revision_register = SMC_GET_REV();
 	DBG(2, "%s: revision = 0x%04x\n", CARDNAME, revision_register);
+	
 	version_string = chip_ids[ (revision_register >> 4) & 0xF];
+	
 	if (!version_string || (revision_register & 0xff00) != 0x3300) {
 		/* I don't recognize this chip, so... */
-		printk("%s: IO %p: Unrecognized revision register 0x%04x"
-			", Contact author.\n", CARDNAME,
-			ioaddr, revision_register);
+		printk("%s: IO %p: Unrecognized revision register 0x%04x, Contact author.\n", CARDNAME, ioaddr, revision_register);
 
 		retval = -ENODEV;
 		goto err_out;
@@ -2105,7 +2076,33 @@
 
 	/* Get the MAC address */
 	SMC_SELECT_BANK(1);
-	SMC_GET_MAC_ADDR(dev->dev_addr);
+	SMC_SET_MAC_ADDR(hw_mac); 
+	//SMC_GET_MAC_ADDR(dev->dev_addr);
+	for(j=0; j<6; j++) 
+	dev->dev_addr[j] = hw_mac[j]; 
+
+
+	/************************************************************************/
+	/* print mac address from device registers */
+	printk("MAC HW DEV address: ");
+	for(j=0; j<6; j++)
+	{
+		printk("%02X",dev->dev_addr[j]);
+		if(j<5) printk(":");
+	}
+	printk("\n");  
+
+	/* print mac address from flash memory */
+	/*macflash = 0xA002020E;
+	printk("MAC HW FLASH address: ");
+	for(j=0; j<6; j++)
+	{
+		printk("%02X",macflash[j]);
+		if(j<5) printk(":");
+	}
+	printk("\n");
+	*/
+	/************************************************************************/
 
 	/* now, reset the chip, and put it into a known state */
 	smc_reset(dev);
@@ -2162,7 +2159,6 @@
 
 	tasklet_init(&lp->tx_task, smc_hardware_send_pkt, (unsigned long)dev);
 	INIT_WORK(&lp->phy_configure, smc_phy_configure);
-	lp->dev = dev;
 	lp->mii.phy_id_mask = 0x1f;
 	lp->mii.reg_num_mask = 0x1f;
 	lp->mii.force_media = 0;
@@ -2192,7 +2188,7 @@
 	}
 
 	/* Grab the IRQ */
-      	retval = request_irq(dev->irq, &smc_interrupt, SMC_IRQ_FLAGS, dev->name, dev);
+      	retval = request_irq(dev->irq, &smc_interrupt, SMC_IRQ_FLAGS, dev->name,dev);
       	if (retval)
       		goto err_out;
 
@@ -2234,6 +2230,8 @@
 			PRINTK("%s: PHY LAN83C183 (LAN91C111 Internal)\n", dev->name);
 		} else if ((lp->phy_type & 0xfffffff0) == 0x02821c50) {
 			PRINTK("%s: PHY LAN83C180\n", dev->name);
+		} else {
+			PRINTK("%s: PHY unknown = 0x%08X\n", dev->name, lp->phy_type);
 		}
 	}
 
@@ -2372,13 +2370,15 @@
  *	0 --> there is a device
  *	anything else, error
  */
+
+
 static int smc_drv_probe(struct platform_device *pdev)
 {
 	struct net_device *ndev;
 	struct resource *res;
 	unsigned int __iomem *addr;
 	int ret;
-
+	// printk(" === smc_drv_probe() === \n");
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-regs");
 	if (!res)
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2424,8 +2424,13 @@
 		ret = -ENOMEM;
 		goto out_release_attrib;
 	}
-
 	platform_set_drvdata(pdev, ndev);
+	// d-mon: we should set up hw ether address befor calling of smc_probe()
+	//SMC_SELECT_BANK(1);
+	//SMC_SET_MAC_ADDR(hw_mac);
+	//ndev->addr_len = 6;
+	//for(i=0; i<6; i++) ndev->dev_addr[i] = hw_mac[i];
+	// ------------------------------
 	ret = smc_probe(ndev, addr);
 	if (ret != 0)
 		goto out_iounmap;
@@ -2509,9 +2514,9 @@
 		smc_enable_device(dev);
 		if (netif_running(ndev)) {
 			smc_reset(ndev);
-			if (lp->phy_type != 0)
-				smc_phy_powerup(ndev);
 			smc_enable(ndev);
+			if (lp->phy_type != 0)
+				smc_phy_configure(ndev);
 			netif_device_attach(ndev);
 		}
 	}
@@ -2530,22 +2535,19 @@
 
 static int __init smc_init(void)
 {
-#ifdef MODULE
-#ifdef CONFIG_ISA
-	if (io == -1)
-		printk(KERN_WARNING
-			"%s: You shouldn't use auto-probing with insmod!\n",
-			CARDNAME);
-#endif
-#endif
-
+	// printk(" === smc_init() === \n");
 	return platform_driver_register(&smc_driver);
 }
 
 static void __exit smc_cleanup(void)
 {
+	// printk(" === smc_cleanup() === \n");
 	platform_driver_unregister(&smc_driver);
 }
 
 module_init(smc_init);
 module_exit(smc_cleanup);
+
+MODULE_DESCRIPTION("SMSC LAN91C113 Ethernet Driver");
+MODULE_AUTHOR("A-De-Beee");
+MODULE_LICENSE("GPL");
diff -Nur linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/smc91x.h linux-sh4/drivers/net/smc91x.h
--- linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/smc91x.h	2011-05-27 18:30:16.000000000 +0200
+++ linux-sh4/drivers/net/smc91x.h	2011-05-01 15:50:08.000000000 +0200
@@ -1,35 +1,5 @@
 /*------------------------------------------------------------------------
  . smc91x.h - macros for SMSC's 91C9x/91C1xx single-chip Ethernet device.
- .
- . Copyright (C) 1996 by Erik Stahlman
- . Copyright (C) 2001 Standard Microsystems Corporation
- .	Developed by Simple Network Magic Corporation
- . Copyright (C) 2003 Monta Vista Software, Inc.
- .	Unified SMC91x driver by Nicolas Pitre
- .
- . This program is free software; you can redistribute it and/or modify
- . it under the terms of the GNU General Public License as published by
- . the Free Software Foundation; either version 2 of the License, or
- . (at your option) any later version.
- .
- . This program is distributed in the hope that it will be useful,
- . but WITHOUT ANY WARRANTY; without even the implied warranty of
- . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- . GNU General Public License for more details.
- .
- . You should have received a copy of the GNU General Public License
- . along with this program; if not, write to the Free Software
- . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- .
- . Information contained in this file was obtained from the LAN91C111
- . manual from SMC.  To get a copy, if you really want one, you can find
- . information under www.smsc.com.
- .
- . Authors
- .	Erik Stahlman		<erik@vt.edu>
- .	Daris A Nevil		<dnevil@snmc.com>
- .	Nicolas Pitre 		<nico@cam.org>
- .
  ---------------------------------------------------------------------------*/
 #ifndef _SMC91X_H_
 #define _SMC91X_H_
@@ -39,480 +9,73 @@
  * Define your architecture specific bus configuration parameters here.
  */
 
-#if	defined(CONFIG_ARCH_LUBBOCK)
-
-/* We can only do 16-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_NOWAIT		1
-
-/* The first two address lines aren't connected... */
-#define SMC_IO_SHIFT		2
-
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
-
-#elif defined(CONFIG_BFIN)
-
-#define SMC_IRQ_FLAGS		IRQF_TRIGGER_HIGH
-#define RPC_LSA_DEFAULT		RPC_LED_100_10
-#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
-
-# if defined (CONFIG_BFIN561_EZKIT)
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	1
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT      	1
-#define SMC_USE_BFIN_DMA	0
-
-
-#define SMC_inw(a, r)       	readw((a) + (r))
-#define SMC_outw(v, a, r)   	writew(v, (a) + (r))
-#define SMC_inl(a, r)       	readl((a) + (r))
-#define SMC_outl(v, a, r)   	writel(v, (a) + (r))
-#define SMC_outsl(a, r, p, l)	outsl((unsigned long *)((a) + (r)), p, l)
-#define SMC_insl(a, r, p, l) 	insl ((unsigned long *)((a) + (r)), p, l)
-# else
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT      	1
-#define SMC_USE_BFIN_DMA	0
-
-
-#define SMC_inw(a, r)       	readw((a) + (r))
-#define SMC_outw(v, a, r)   	writew(v, (a) + (r))
-#define SMC_outsw(a, r, p, l)	outsw((unsigned long *)((a) + (r)), p, l)
-#define SMC_insw(a, r, p, l) 	insw ((unsigned long *)((a) + (r)), p, l)
-# endif
-/* check if the mac in reg is valid */
-#define SMC_GET_MAC_ADDR(addr)					\
-	do {							\
-		unsigned int __v;				\
-		__v = SMC_inw(ioaddr, ADDR0_REG);		\
-		addr[0] = __v; addr[1] = __v >> 8;		\
-		__v = SMC_inw(ioaddr, ADDR1_REG);		\
-		addr[2] = __v; addr[3] = __v >> 8;		\
-		__v = SMC_inw(ioaddr, ADDR2_REG);		\
-		addr[4] = __v; addr[5] = __v >> 8;		\
-		if (*(u32 *)(&addr[0]) == 0xFFFFFFFF) {		\
-			random_ether_addr(addr);		\
-		}						\
-	} while (0)
-#elif defined(CONFIG_REDWOOD_5) || defined(CONFIG_REDWOOD_6)
-
-/* We can only do 16-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_NOWAIT		1
-
-#define SMC_IO_SHIFT		0
-
-#define SMC_inw(a, r)		in_be16((volatile u16 *)((a) + (r)))
-#define SMC_outw(v, a, r)	out_be16((volatile u16 *)((a) + (r)), v)
-#define SMC_insw(a, r, p, l) 						\
-	do {								\
-		unsigned long __port = (a) + (r);			\
-		u16 *__p = (u16 *)(p);					\
-		int __l = (l);						\
-		insw(__port, __p, __l);					\
-		while (__l > 0) {					\
-			*__p = swab16(*__p);				\
-			__p++;						\
-			__l--;						\
-		}							\
-	} while (0)
-#define SMC_outsw(a, r, p, l) 						\
-	do {								\
-		unsigned long __port = (a) + (r);			\
-		u16 *__p = (u16 *)(p);					\
-		int __l = (l);						\
-		while (__l > 0) {					\
-			/* Believe it or not, the swab isn't needed. */	\
-			outw( /* swab16 */ (*__p++), __port);		\
-			__l--;						\
-		}							\
-	} while (0)
-#define SMC_IRQ_FLAGS		(0)
-
-#elif defined(CONFIG_SA1100_PLEB)
-/* We can only do 16-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT		1
-
-#define SMC_inb(a, r)		readb((a) + (r))
-#define SMC_insb(a, r, p, l)	readsb((a) + (r), p, (l))
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
-#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
-#define SMC_outsb(a, r, p, l)	writesb((a) + (r), p, (l))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
-
-#define SMC_IRQ_FLAGS		(0)
-
-#elif defined(CONFIG_SA1100_ASSABET)
-
-#include <asm/arch/neponset.h>
-
-/* We can only do 8-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	0
-#define SMC_CAN_USE_32BIT	0
-#define SMC_NOWAIT		1
-
-/* The first two address lines aren't connected... */
-#define SMC_IO_SHIFT		2
-
-#define SMC_inb(a, r)		readb((a) + (r))
-#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
-#define SMC_insb(a, r, p, l)	readsb((a) + (r), p, (l))
-#define SMC_outsb(a, r, p, l)	writesb((a) + (r), p, (l))
-
-#elif	defined(CONFIG_MACH_LOGICPD_PXA270)
-
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT		1
-
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
-
-#elif	defined(CONFIG_ARCH_INNOKOM) || \
-	defined(CONFIG_MACH_MAINSTONE) || \
-	defined(CONFIG_ARCH_PXA_IDP) || \
-	defined(CONFIG_ARCH_RAMSES)
-
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	1
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT		1
-#define SMC_USE_PXA_DMA		1
-
-#define SMC_inb(a, r)		readb((a) + (r))
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_inl(a, r)		readl((a) + (r))
-#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
-#define SMC_outl(v, a, r)	writel(v, (a) + (r))
-#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
-#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
-
-/* We actually can't write halfwords properly if not word aligned */
-static inline void
-SMC_outw(u16 val, void __iomem *ioaddr, int reg)
-{
-	if (reg & 2) {
-		unsigned int v = val << 16;
-		v |= readl(ioaddr + (reg & ~2)) & 0xffff;
-		writel(v, ioaddr + (reg & ~2));
-	} else {
-		writew(val, ioaddr + reg);
-	}
-}
-
-#elif	defined(CONFIG_ARCH_OMAP)
-
-/* We can only do 16-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT		1
-
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
-
-#include <asm/mach-types.h>
-#include <asm/arch/cpu.h>
-
-#define	SMC_IRQ_FLAGS (( \
-		   machine_is_omap_h2() \
-		|| machine_is_omap_h3() \
-		|| machine_is_omap_h4() \
-		|| (machine_is_omap_innovator() && !cpu_is_omap1510()) \
-	) ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING)
-
-
-#elif	defined(CONFIG_SH_SH4202_MICRODEV)
-
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-
-#define SMC_inb(a, r)		inb((a) + (r) - 0xa0000000)
-#define SMC_inw(a, r)		inw((a) + (r) - 0xa0000000)
-#define SMC_inl(a, r)		inl((a) + (r) - 0xa0000000)
-#define SMC_outb(v, a, r)	outb(v, (a) + (r) - 0xa0000000)
-#define SMC_outw(v, a, r)	outw(v, (a) + (r) - 0xa0000000)
-#define SMC_outl(v, a, r)	outl(v, (a) + (r) - 0xa0000000)
-#define SMC_insl(a, r, p, l)	insl((a) + (r) - 0xa0000000, p, l)
-#define SMC_outsl(a, r, p, l)	outsl((a) + (r) - 0xa0000000, p, l)
-#define SMC_insw(a, r, p, l)	insw((a) + (r) - 0xa0000000, p, l)
-#define SMC_outsw(a, r, p, l)	outsw((a) + (r) - 0xa0000000, p, l)
-
-#define SMC_IRQ_FLAGS		(0)
-
-#elif defined(CONFIG_CPU_SUBTYPE_ST40)
-
-#if defined(CONFIG_SH_ST_MB411) || \
-      defined(CONFIG_SH_ST_MB442) || \
-      defined(CONFIG_SH_ST_MB448)
-/* 16 bit on board SMC91C111. No address shifting required.
- * Note we can't set SMC_CAN_USE_32BIT. This would causes SMC_SELECT_BANK
- * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
- * This bypasses the special logic which would prevent this also updating
- * this interrupt mask register. */
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_CAN_USE_32BIT_DATA	1
-#define SMC_IO_SHIFT		0
-#else
-#error Unknown board
-#endif
-
-#define SMC_NOWAIT		0
-#define SMC_IRQ_FLAGS		0
-
-#ifdef SMC_STEM_BS_MASK
-/*
- * We have to shift all addresses up by 1, because the STEM
- * module connects A2 from the CPU to to A1 on the SMC device.
- * This was done for compatibility with the ST20 EMI, which
- * apparently does the opposite.
- * However the byte strobes are not shifted in hardware, so
- * these need to be left in place.
- */
-#define REG_OFFSET(base,reg) ({                         		\
-        u_int __reg = (reg);                            		\
-        __reg = ( (__reg & (~SMC_STEM_BS_MASK))                 ) |	\
-                ( (__reg & ( SMC_STEM_BS_MASK)) >> SMC_IO_SHIFT );	\
-	(void __iomem *)((base) + __reg); })
-#else
-#define REG_OFFSET(base,reg) ((void __iomem*)((base) + (reg)))
-#endif
-
-#define dprintk(str, ...) // printk(str, ## __VA_ARGS__)
-#define SMC_inb(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = readb(_p); dprintk("SMC_inb(%08p) = %02x\n", _p, _v); _v; })
-#define SMC_inw(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = readw(_p); dprintk("SMC_inw(%08p) = %04x\n", _p, _v); _v; })
-#define SMC_inl(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = readl(_p); dprintk("SMC_inl(%08p) = %08x\n", _p, _v); _v; })
-#define SMC_outb(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = (v);  dprintk("SMC_outb(%02x, %08p)\n", _v, _p); writeb(_v, _p); })
-#define SMC_outw(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = (v);  dprintk("SMC_outw(%04x, %08p)\n", _v, _p); writew(_v, _p); })
-#define SMC_outl(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = (v);  dprintk("SMC_outl(%08x, %08p)\n", _v, _p); writel(_v, _p); })
-#define SMC_insl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); readsl(_p, p, l); })
-#define SMC_outsl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); writesl(_p, p, l); })
-
-#define set_irq_type(irq, type)
-
-#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
-#define RPC_LSB_DEFAULT		RPC_LED_100_10
-
-#elif	defined(CONFIG_ISA)
-
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-
-#define SMC_inb(a, r)		inb((a) + (r))
-#define SMC_inw(a, r)		inw((a) + (r))
-#define SMC_outb(v, a, r)	outb(v, (a) + (r))
-#define SMC_outw(v, a, r)	outw(v, (a) + (r))
-#define SMC_insw(a, r, p, l)	insw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)	outsw((a) + (r), p, l)
-
-#elif   defined(CONFIG_SUPERH)
-
-#ifdef CONFIG_SOLUTION_ENGINE
-#define SMC_CAN_USE_8BIT       0
-#define SMC_CAN_USE_16BIT      1
-#define SMC_CAN_USE_32BIT      0
-#define SMC_IO_SHIFT           0
-#define SMC_NOWAIT             1
-
-#define SMC_inw(a, r)          inw((a) + (r))
-#define SMC_outw(v, a, r)      outw(v, (a) + (r))
-#define SMC_insw(a, r, p, l)   insw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)  outsw((a) + (r), p, l)
-
-#else /* BOARDS */
-
-#define SMC_CAN_USE_8BIT       1
-#define SMC_CAN_USE_16BIT      1
-#define SMC_CAN_USE_32BIT      0
-
-#define SMC_inb(a, r)          inb((a) + (r))
-#define SMC_inw(a, r)          inw((a) + (r))
-#define SMC_outb(v, a, r)      outb(v, (a) + (r))
-#define SMC_outw(v, a, r)      outw(v, (a) + (r))
-#define SMC_insw(a, r, p, l)   insw((a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)  outsw((a) + (r), p, l)
-
-#endif  /* BOARDS */
-
-#elif   defined(CONFIG_M32R)
-
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-
-#define SMC_inb(a, r)		inb(((u32)a) + (r))
-#define SMC_inw(a, r)		inw(((u32)a) + (r))
-#define SMC_outb(v, a, r)	outb(v, ((u32)a) + (r))
-#define SMC_outw(v, a, r)	outw(v, ((u32)a) + (r))
-#define SMC_insw(a, r, p, l)	insw(((u32)a) + (r), p, l)
-#define SMC_outsw(a, r, p, l)	outsw(((u32)a) + (r), p, l)
-
-#define SMC_IRQ_FLAGS		(0)
-
-#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
-#define RPC_LSB_DEFAULT		RPC_LED_100_10
-
-#elif   defined(CONFIG_MACH_LPD79520) \
-     || defined(CONFIG_MACH_LPD7A400) \
-     || defined(CONFIG_MACH_LPD7A404)
-
-/* The LPD7X_IOBARRIER is necessary to overcome a mismatch between the
- * way that the CPU handles chip selects and the way that the SMC chip
- * expects the chip select to operate.  Refer to
- * Documentation/arm/Sharp-LH/IOBarrier for details.  The read from
- * IOBARRIER is a byte, in order that we read the least-common
- * denominator.  It would be wasteful to read 32 bits from an 8-bit
- * accessible region.
- *
- * There is no explicit protection against interrupts intervening
- * between the writew and the IOBARRIER.  In SMC ISR there is a
- * preamble that performs an IOBARRIER in the extremely unlikely event
- * that the driver interrupts itself between a writew to the chip an
- * the IOBARRIER that follows *and* the cache is large enough that the
- * first off-chip access while handing the interrupt is to the SMC
- * chip.  Other devices in the same address space as the SMC chip must
- * be aware of the potential for trouble and perform a similar
- * IOBARRIER on entry to their ISR.
- */
-
-#include <asm/arch/constants.h>	/* IOBARRIER_VIRT */
-
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_NOWAIT		0
-#define LPD7X_IOBARRIER		readb (IOBARRIER_VIRT)
-
-#define SMC_inw(a,r)\
-   ({ unsigned short v = readw ((void*) ((a) + (r))); LPD7X_IOBARRIER; v; })
-#define SMC_outw(v,a,r)	  ({ writew ((v), (a) + (r)); LPD7X_IOBARRIER; })
-
-#define SMC_insw		LPD7_SMC_insw
-static inline void LPD7_SMC_insw (unsigned char* a, int r,
-				  unsigned char* p, int l)
-{
-	unsigned short* ps = (unsigned short*) p;
-	while (l-- > 0) {
-		*ps++ = readw (a + r);
-		LPD7X_IOBARRIER;
-	}
-}
-
-#define SMC_outsw		LPD7_SMC_outsw
-static inline void LPD7_SMC_outsw (unsigned char* a, int r,
-				   unsigned char* p, int l)
-{
-	unsigned short* ps = (unsigned short*) p;
-	while (l-- > 0) {
-		writew (*ps++, a + r);
-		LPD7X_IOBARRIER;
-	}
-}
-
-#define SMC_INTERRUPT_PREAMBLE	LPD7X_IOBARRIER
-
-#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
-#define RPC_LSB_DEFAULT		RPC_LED_100_10
-
-#elif defined(CONFIG_SOC_AU1X00)
-
-#include <au1xxx.h>
-
-/* We can only do 16-bit reads and writes in the static memory space. */
-#define SMC_CAN_USE_8BIT	0
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	0
-#define SMC_IO_SHIFT		0
-#define SMC_NOWAIT		1
-
-#define SMC_inw(a, r)		au_readw((unsigned long)((a) + (r)))
-#define SMC_insw(a, r, p, l)	\
-	do {	\
-		unsigned long _a = (unsigned long)((a) + (r)); \
-		int _l = (l); \
-		u16 *_p = (u16 *)(p); \
-		while (_l-- > 0) \
-			*_p++ = au_readw(_a); \
-	} while(0)
-#define SMC_outw(v, a, r)	au_writew(v, (unsigned long)((a) + (r)))
-#define SMC_outsw(a, r, p, l)	\
-	do {	\
-		unsigned long _a = (unsigned long)((a) + (r)); \
-		int _l = (l); \
-		const u16 *_p = (const u16 *)(p); \
-		while (_l-- > 0) \
-			au_writew(*_p++ , _a); \
-	} while(0)
-
-#define SMC_IRQ_FLAGS		(0)
-
-#elif	defined(CONFIG_ARCH_VERSATILE)
-
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	1
-#define SMC_NOWAIT		1
-
-#define SMC_inb(a, r)		readb((a) + (r))
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_inl(a, r)		readl((a) + (r))
-#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_outl(v, a, r)	writel(v, (a) + (r))
-#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
-#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+#if defined(CONFIG_CPU_SUBTYPE_ST40)
 
-#define SMC_IRQ_FLAGS		(0)
-
-#else
-
-#define SMC_CAN_USE_8BIT	1
-#define SMC_CAN_USE_16BIT	1
-#define SMC_CAN_USE_32BIT	1
-#define SMC_NOWAIT		1
-
-#define SMC_inb(a, r)		readb((a) + (r))
-#define SMC_inw(a, r)		readw((a) + (r))
-#define SMC_inl(a, r)		readl((a) + (r))
-#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
-#define SMC_outw(v, a, r)	writew(v, (a) + (r))
-#define SMC_outl(v, a, r)	writel(v, (a) + (r))
-#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
-#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
-
-#define RPC_LSA_DEFAULT		RPC_LED_100_10
-#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
+		/* 16 bit on board SMC91C111. No address shifting required.
+		 * Note we can't set SMC_CAN_USE_32BIT. This would causes SMC_SELECT_BANK
+		 * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
+		 * This bypasses the special logic which would prevent this also updating
+		 * this interrupt mask register. */
+		#define SMC_CAN_USE_8BIT	0
+		#define SMC_CAN_USE_16BIT	1
+		#define SMC_CAN_USE_32BIT	0
+		#define SMC_CAN_USE_32BIT_DATA	1
+		#define SMC_IO_SHIFT		14
+
+	#define SMC_NOWAIT		1
+	#undef  SMC_USE_PXA_DMA
+
+	#ifdef SMC_STEM_BS_MASK
+		/*
+		 * We have to shift all addresses up by 1, because the STEM
+		 * module connects A2 from the CPU to to A1 on the SMC device.
+		 * This was done for compatibility with the ST20 EMI, which
+		 * apparently does the opposite.
+		 * However the byte strobes are not shifted in hardware, so
+		 * these need to be left in place.
+		 */
+		#define REG_OFFSET(base,reg) ({                         		\
+		        u_int __reg = (reg);                            		\
+		        __reg = ( (__reg & (~SMC_STEM_BS_MASK))                 ) |	\
+		                ( (__reg & ( SMC_STEM_BS_MASK)) >> SMC_IO_SHIFT );	\
+			(void __iomem *)((base) + __reg); })
+	#else
+		#define REG_OFFSET(base,reg) ((void __iomem*)((base) + (reg)))
+	#endif
+
+	#define dprintk(str, ...)  //printk(str, ## __VA_ARGS__)
+	#define SMC_inb(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = readb(_p); dprintk("SMC_inb(%08p) = %02x\n", _p, _v); _v; })
+	#define SMC_inw(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = readw(_p); dprintk("SMC_inw(%08p) = %04x\n", _p, _v); _v; })
+	#define SMC_inl(a, r)		({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = readl(_p); dprintk("SMC_inl(%08p) = %08x\n", _p, _v); _v; })
+	#define SMC_outb(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u8  _v = (v);  dprintk("SMC_outb(%02x, %08p)\n", _v, _p); writeb(_v, _p); })
+	#define SMC_outw(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u16 _v = (v);  dprintk("SMC_outw(%04x, %08p)\n", _v, _p); writew(_v, _p); })
+	#define SMC_outl(v, a, r)	({ void __iomem *_p = REG_OFFSET((a), (r)); u32 _v = (v);  dprintk("SMC_outl(%08x, %08p)\n", _v, _p); writel(_v, _p); })
+	#define SMC_insl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); readsl(_p, p, l); })
+	#define SMC_outsl(a, r, p, l)	({ void __iomem *_p = REG_OFFSET((a), (r)); writesl(_p, p, l); })
+	
+	#define set_irq_type(irq, type)
+	
+	#define RPC_LSA_DEFAULT		RPC_LED_TX_RX
+	#define RPC_LSB_DEFAULT		RPC_LED_100_10
+	
+#else /* another platform */
+
+	#define SMC_CAN_USE_8BIT	0
+	#define SMC_CAN_USE_16BIT	1
+	#define SMC_CAN_USE_32BIT	0
+	#define SMC_NOWAIT			0
+	
+	#define SMC_inb(a, r)		readb((a) + (r))
+	#define SMC_inw(a, r)		readw((a) + (r))
+	#define SMC_inl(a, r)		readl((a) + (r))
+	#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
+	#define SMC_outw(v, a, r)	writew(v, (a) + (r))
+	#define SMC_outl(v, a, r)	writel(v, (a) + (r))
+	#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
+	#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+	
+	#define RPC_LSA_DEFAULT		RPC_LED_100_10
+	#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
 
 #endif
 
@@ -529,11 +92,9 @@
 
 #ifdef SMC_insl
 #undef SMC_insl
-#define SMC_insl(a, r, p, l) \
-	smc_pxa_dma_insl(a, lp->physaddr, r, dev->dma, p, l)
-static inline void
-smc_pxa_dma_insl(void __iomem *ioaddr, u_long physaddr, int reg, int dma,
-		 u_char *buf, int len)
+#define SMC_insl(a, r, p, l) smc_pxa_dma_insl(a, lp->physaddr, r, dev->dma, p, l)
+
+static inline void smc_pxa_dma_insl(void __iomem *ioaddr, u_long physaddr, int reg, int dma, u_char *buf, int len)
 {
 	dma_addr_t dmabuf;
 
@@ -567,11 +128,9 @@
 
 #ifdef SMC_insw
 #undef SMC_insw
-#define SMC_insw(a, r, p, l) \
-	smc_pxa_dma_insw(a, lp->physaddr, r, dev->dma, p, l)
-static inline void
-smc_pxa_dma_insw(void __iomem *ioaddr, u_long physaddr, int reg, int dma,
-		 u_char *buf, int len)
+#define SMC_insw(a, r, p, l)  smc_pxa_dma_insw(a, lp->physaddr, r, dev->dma, p, l)
+
+static inline void smc_pxa_dma_insw(void __iomem *ioaddr, u_long physaddr, int reg, int dma, u_char *buf, int len)
 {
 	dma_addr_t dmabuf;
 
@@ -603,8 +162,7 @@
 }
 #endif
 
-static void
-smc_pxa_dma_irq(int dma, void *dummy)
+static void smc_pxa_dma_irq(int dma, void *dummy, struct pt_regs *regs)
 {
 	DCSR(dma) = 0;
 }
@@ -619,15 +177,16 @@
  */
 
 #if ! (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA)
-#define SMC_inl(ioaddr, reg)		({ BUG(); 0; })
-#define SMC_outl(x, ioaddr, reg)	BUG()
-#define SMC_insl(a, r, p, l)		BUG()
-#define SMC_outsl(a, r, p, l)		BUG()
+	#define SMC_inl(ioaddr, reg)		({ BUG(); 0; })
+	#define SMC_outl(x, ioaddr, reg)	BUG()
+/*	#define SMC_insl(a, r, p, l)		BUG() // d-mon: we definitely need this for SMC_PULL_DATA 
+	#define SMC_outsl(a, r, p, l)		BUG() // for SMC_PUSH_DATA
+*/
 #endif
 
 #if !defined(SMC_insl) || !defined(SMC_outsl)
-#define SMC_insl(a, r, p, l)		BUG()
-#define SMC_outsl(a, r, p, l)		BUG()
+	#define SMC_insl(a, r, p, l)		BUG()
+	#define SMC_outsl(a, r, p, l)		BUG()
 #endif
 
 #if ! SMC_CAN_USE_16BIT
@@ -661,8 +220,8 @@
 #endif
 
 #if ! SMC_CAN_USE_8BIT
-#define SMC_inb(ioaddr, reg)		({ BUG(); 0; })
-#define SMC_outb(x, ioaddr, reg)	BUG()
+//#define SMC_inb(ioaddr, reg)		({ BUG(); 0; })
+//#define SMC_outb(x, ioaddr, reg)	BUG()
 #define SMC_insb(a, r, p, l)		BUG()
 #define SMC_outsb(a, r, p, l)		BUG()
 #endif
@@ -681,7 +240,7 @@
 #endif
 
 #ifndef	SMC_IRQ_FLAGS
-#define	SMC_IRQ_FLAGS		IRQF_TRIGGER_RISING
+#define	SMC_IRQ_FLAGS		SA_TRIGGER_RISING
 #endif
 
 #ifndef SMC_INTERRUPT_PREAMBLE
@@ -792,8 +351,8 @@
 #define RPC_LSB_DEFAULT RPC_LED_FD
 #endif
 
-#define RPC_DEFAULT (RPC_ANEG | (RPC_LSA_DEFAULT << RPC_LSXA_SHFT) | (RPC_LSB_DEFAULT << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
-
+//#define RPC_DEFAULT (RPC_ANEG | (RPC_LSA_DEFAULT << RPC_LSXA_SHFT) | (RPC_LSB_DEFAULT << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+#define RPC_DEFAULT (RPC_SPEED | RPC_DPLX | RPC_ANEG | (RPC_LED_TX_RX << RPC_LSXA_SHFT))
 
 /* Bank 0 0x0C is reserved */
 
@@ -805,7 +364,7 @@
 // Configuration Reg
 /* BANK 1 */
 #define CONFIG_REG	SMC_REG(0x0000,	1)
-#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_EXT_PHY	0x0300	// 1=external MII, 0=internal Phy tutaj 200
 #define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
 #define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
 #define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
@@ -1230,20 +789,20 @@
 #define SMC_GET_MAC_ADDR(addr)						\
 	do {								\
 		unsigned int __v;					\
-		__v = SMC_inw( ioaddr, ADDR0_REG );			\
+		__v = SMC_inw( macioaddr, 0 );			\
 		addr[0] = __v; addr[1] = __v >> 8;			\
-		__v = SMC_inw( ioaddr, ADDR1_REG );			\
+		__v = SMC_inw( macioaddr, 2 );			\
 		addr[2] = __v; addr[3] = __v >> 8;			\
-		__v = SMC_inw( ioaddr, ADDR2_REG );			\
+		__v = SMC_inw( macioaddr, 4 );			\
 		addr[4] = __v; addr[5] = __v >> 8;			\
 	} while (0)
 #endif
 
 #define SMC_SET_MAC_ADDR(addr)						\
 	do {								\
-		SMC_outw( addr[0]|(addr[1] << 8), ioaddr, ADDR0_REG );	\
-		SMC_outw( addr[2]|(addr[3] << 8), ioaddr, ADDR1_REG );	\
-		SMC_outw( addr[4]|(addr[5] << 8), ioaddr, ADDR2_REG );	\
+		SMC_outw( addr[0]|(addr[1] << 8), macioaddr, 0 );	\
+		SMC_outw( addr[2]|(addr[3] << 8), macioaddr, 2 );	\
+		SMC_outw( addr[4]|(addr[5] << 8), macioaddr, 4 );	\
 	} while (0)
 
 #define SMC_SET_MCAST(x)						\
@@ -1282,7 +841,7 @@
 		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
-			void __iomem *__ioaddr = ioaddr;		\
+			void *__ioaddr = ioaddr;			\
 			if (__len >= 2 && (unsigned long)__ptr & 2) {	\
 				__len -= 2;				\
 				SMC_outw(*(u16 *)__ptr, ioaddr, DATA_REG); \
@@ -1306,7 +865,7 @@
 		if (SMC_CAN_USE_32BIT || SMC_CAN_USE_32BIT_DATA) {	\
 			void *__ptr = (p);				\
 			int __len = (l);				\
-			void __iomem *__ioaddr = ioaddr;		\
+			void *__ioaddr = ioaddr;			\
 			if ((unsigned long)__ptr & 2) {			\
 				/*					\
 				 * We want 32bit alignment here.	\
@@ -1335,21 +894,5 @@
 			SMC_insb(ioaddr, DATA_REG, p, l);		\
 	} while (0)
 
-#if defined(CONFIG_SH_STI5528_ESPRESSO)
-/*
- * The Espresso doesn't appear to correctly connect the SMSC's ARDY pin
- * to the 5528's WAIT pin. The only time this has been observed to be a
- * problem is after setting the pointer register there may be insufficient
- * delay before reading from the FIFO. Insert a delay here.
- */
-#undef SMC_SET_PTR
-#define SMC_SET_PTR(x)							\
-	do {								\
-		unsigned int __val16 = (x);				\
-		SMC_outw( __val16, ioaddr, PTR_REG );			\
-		if (__val16 & PTR_READ)					\
-			ndelay(370);					\
-	} while (0)
-#endif
 
 #endif  /* _SMC91X_H_ */
diff -Nur linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/stmmac/common.h linux-sh4/drivers/net/stmmac/common.h
--- linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/stmmac/common.h	2011-05-27 18:30:20.000000000 +0200
+++ linux-sh4/drivers/net/stmmac/common.h	2011-05-01 20:45:50.000000000 +0200
@@ -221,12 +221,21 @@
 	lo_addr = readl(ioaddr + low);
 
 	/* Extract the MAC address from the high and low words */
+#if 1
+	addr[0] = 0;
+	addr[1] = 0;
+	addr[2] = 0;
+	addr[3] = 0;
+	addr[4] = 0;
+	addr[5] = 0;
+#else
 	addr[0] = lo_addr & 0xff;
 	addr[1] = (lo_addr >> 8) & 0xff;
 	addr[2] = (lo_addr >> 16) & 0xff;
 	addr[3] = (lo_addr >> 24) & 0xff;
 	addr[4] = hi_addr & 0xff;
 	addr[5] = (hi_addr >> 8) & 0xff;
+#endif
 
 	return;
 }
diff -Nur linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/stmmac/stmmac_main.c linux-sh4/drivers/net/stmmac/stmmac_main.c
--- linux-sh4-2.6.23.17_stm23_0123_orig/drivers/net/stmmac/stmmac_main.c	2011-05-27 18:30:22.000000000 +0200
+++ linux-sh4/drivers/net/stmmac/stmmac_main.c	2011-05-01 20:45:50.000000000 +0200
@@ -1887,8 +1887,8 @@
 	stmmac_init_coalescence(priv->is_gmac, dev->mtu);
 
 	if (!is_valid_ether_addr(dev->dev_addr)) {
-		printk(KERN_WARNING "\tno valid MAC address; "
-		       "please, set using ifconfig or nwhwconfig!\n");
+		/*printk(KERN_WARNING "\tno valid MAC address; "
+		       "please, set using ifconfig or nwhwconfig!\n");*/
 	}
 
 	ret = register_netdev(dev);
