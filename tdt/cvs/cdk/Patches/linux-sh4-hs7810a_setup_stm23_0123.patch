*** linux-sh4/arch/sh/kernel/setup.c	2011-01-05 10:45:31.000000000 +0100
--- setup.c.patched	2011-01-22 12:22:31.340928000 +0100
***************
*** 276,281 ****
--- 276,309 ----
  #endif
  #endif
  
+ 	{
+ 	char org_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock3";
+ 	char tdt_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock3 rw rootfstype=jffs2 init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1 console_loglevel=7 stmmaceth=ethaddr:";
+ 	char mac[] = "00:00:00:00:00:00";
+ 	int command_line_len = strlen(command_line);
+ 	int org_command_line_len = strlen(org_command_line);
+ 
+ 	//if(command_line_len >= org_command_line_len && !strncmp(command_line, org_command_line, org_command_line_len))
+ 	{
+ 		int i;
+ 		for(i = 0; i < (command_line_len - 7); i++)
+ 		{
+ 			if(!strncmp(command_line + i, "ethaddr", 7))
+ 			{
+ 				strlcpy(mac, command_line + i + 8, sizeof(mac));
+ 				break;
+ 			}
+ 			if(!strncmp(command_line + i, "hwaddr", 6))
+ 			{
+ 				strlcpy(mac, command_line + i + 7, sizeof(mac));
+ 				break;
+ 			}
+ 		}
+ 		strlcpy(command_line, tdt_command_line, sizeof(command_line));
+ 		strlcat(command_line, mac, sizeof(command_line));
+ 	}
+ 	}
+ 
  	/* Save unparsed command line copy for /proc/cmdline */
  	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
  	*cmdline_p = command_line;

diff -rcN linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/boards/st/sat7111/Makefile linux-sh4/arch/sh/boards/st/sat7111/Makefile
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/boards/st/sat7111/Makefile	1970-01-01 02:00:00.000000000 +0200
--- linux-sh4/arch/sh/boards/st/sat7111/Makefile	2011-07-29 06:50:50.654192548 +0300
***************
*** 0 ****
--- 1,5 ----
+ #
+ # Makefile for STMicroelectronics STi7111SAT board
+ #
+ 
+ obj-y := setup.o
diff -rcN linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/boards/st/sat7111/setup.c linux-sh4/arch/sh/boards/st/sat7111/setup.c
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/boards/st/sat7111/setup.c	1970-01-01 02:00:00.000000000 +0200
--- linux-sh4/arch/sh/boards/st/sat7111/setup.c	2011-07-29 06:50:50.654192548 +0300
***************
*** 0 ****
--- 1,414 ----
+ /*
+  * arch/sh/boards/st/sat7111/setup.c
+  *
+  * Copyright (C) 2008 STMicroelectronics Limited
+  * Author: Stuart Menefy (stuart.menefy@st.com)
+  *
+  * May be copied or modified under the terms of the GNU General Public
+  * License.  See linux/COPYING for more information.
+  *
+  * STMicroelectronics STx7111 Mboard support.
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/leds.h>
+ #include <linux/stm/pio.h>
+ #include <linux/stm/soc.h>
+ #include <linux/stm/emi.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/physmap.h>
+ #include <linux/mtd/partitions.h>
+ #include <linux/bpa2.h>
+ #include <linux/phy.h>
+ #include <linux/delay.h>
+ #include <linux/lirc.h>
+ #include <linux/gpio_keys.h>
+ #include <linux/input.h>
+ #include <asm/irq-ilc.h>
+ #include <asm/irl.h>
+ #include <asm/io.h>
+ #include "../common/common.h"
+ 
+ const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                     "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+  
+ /*
+ 0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+ 0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+ 0x40800000 - 0x47FFFFFF - linux   (120mb) 
+ 0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+ 0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+ */
+ static struct bpa2_partition_desc bpa2_parts_table[] = {
+     {
+  	    .name  = "bigphysarea",
+  	    .start = 0x48000000,
+  	    .size  = 0x02000000, /* 32 Mb */
+  	    .flags = 0,
+  	    .aka   = NULL
+     }, 
+     {
+  	    .name  = "LMI_IO",
+  	    .start = 0x4A000000,
+  	    .size  = 0x06000000, /* 92 Mb */
+  	    .flags = 0,
+  	    .aka   = LMI_IO_partalias
+     }, 
+  };
+ 
+ /* Whether the hardware supports NOR or NAND Flash depends on J34.
+  * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
+  * Note that J30A must be in position 2-3 to select the on board Flash
+  * (both NOR and NAND).
+  */
+ #define FLASH_NOR
+ 
+ static int ascs[2] __initdata = { 2 | STASC_FLAG_NORTSCTS << 8, 3 | STASC_FLAG_NORTSCTS << 8};
+ 
+ static void __init sat7111_setup(char** cmdline_p)
+ {
+ 	printk("STMicroelectronics sat7111 initialisation\n");
+ 
+ 	stx7111_early_device_init();
+ 	stx7111_configure_asc(ascs, 2, 0);
+   	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+ }
+ 
+ static struct plat_stm_pwm_data pwm_private_info = {
+ 	.flags		= PLAT_STM_PWM_OUT0,
+ };
+ 
+ static struct plat_ssc_data ssc_private_info = {
+ 	.capability  =
+ 		ssc0_has(SSC_I2C_CAPABILITY) |
+ 		ssc1_has(SSC_I2C_CAPABILITY) |
+ 		ssc2_has(SSC_I2C_CAPABILITY) |
+ 		ssc3_has(SSC_I2C_CAPABILITY),
+ };
+ 
+ static struct platform_device sat7111_leds = {
+ 	.name = "leds-gpio",
+ 	.id = -1,
+ 	.dev.platform_data = &(struct gpio_led_platform_data) {
+ 		.num_leds = 2,
+ 		.leds = (struct gpio_led[]) {
+ 			{
+ 				.name = "HB red",
+ 				.default_trigger = "error",
+ 				.gpio = stpio_to_gpio(3, 5),
+ 			},
+ 			{
+ 				.name = "HB white",
+ 				.default_trigger = "power",
+ 				.gpio = stpio_to_gpio(3, 0),
+ 			},
+ 		},
+ 	},
+ };
+ 
+ static struct gpio_keys_button sat7111_buttons[] = {
+ 	{
+ 		.code = BTN_0,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD1",
+ 	},
+ 	{
+ 		.code = BTN_1,
+ 		.gpio = stpio_to_gpio(6, 3),
+ 		.desc = "KD2",
+ 	},
+ 	{
+ 		.code = BTN_2,
+ 		.gpio = stpio_to_gpio(6, 4),
+ 		.desc = "KD3",
+ 	},
+ 	{
+ 		.code = BTN_3,
+ 		.gpio = stpio_to_gpio(6, 5),
+ 		.desc = "KD4",
+ 	},
+ 	{
+ 		.code = BTN_4,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD5",
+ 	},
+ 	{
+ 		.code = BTN_5,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD6",
+ 	},
+ 	{
+ 		.code = BTN_6,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD7",
+ 	},
+ 	{
+ 		.code = BTN_7,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD8",
+ 	},
+ 	{
+ 		.code = BTN_8,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD9",
+ 	},
+ 	{
+ 		.code = BTN_9,
+ 		.gpio = stpio_to_gpio(6, 2),
+ 		.desc = "KD10",
+ 	},
+ };
+ 
+ static struct gpio_keys_platform_data sat7111_button_data = {
+ 	.buttons = sat7111_buttons,
+ 	.nbuttons = ARRAY_SIZE(sat7111_buttons),
+ };
+ 
+ static struct platform_device sat7111_button_device = {
+ 	.name = "gpio-keys",
+ 	.id = -1,
+ 	.num_resources = 0,
+ 	.dev = {
+ 		.platform_data = &sat7111_button_data,
+ 	}
+ };
+ 
+ /* J34 must be in the 2-3 position to enable NOR Flash */
+ static struct stpio_pin *vpp_pio;
+ static struct stpio_pin *phy_reset_pio;
+ static struct stpio_pin *usb_reset_pio;
+ 
+ static void set_vpp(struct map_info * info, int enable)
+ {
+ 	stpio_set_pin(vpp_pio, enable);
+ }
+ 
+ static struct mtd_partition mtd_parts_table[10] = {
+ 	{
+ 	 .name = "Boot firmware",
+ 	 .size = 0x00100000,
+ 	 .offset = 0x00000000,
+ 	 },
+ 	{
+ 	 .name = "Kernel",
+ 	 .size = 0x00200000, //2M
+ 	 .offset = 0x00100000,
+ 	 }, 
+ 
+ 	{
+ 	 .name = "APP",
+ 	 .size = 0x00a00000,	//10M
+ 	 .offset = 0x00300000,
+ 	 },
+ 
+ 	{
+ 	 .name = "ROOT FS",
+ 	 .size = 0x00b00000,	//11M
+ 	 .offset = 0x00d00000, 
+ 	 },	 	 
+ 	{
+ 	 .name = "Device",
+ 	 .size = 0x00300000,	// 3M
+ 	 .offset = 0x01800000,
+ 	 },
+ 	{
+ 	 .name = "Config",
+ 	 .size = 0x00100000,	
+ 	 .offset = 0x01b00000, // 1.2M
+ 	 },
+ 	{
+ 	 .name = "User",
+ 	 .size = MTDPART_SIZ_FULL,	
+ 	 .offset = 0x01c00000, // 4M
+ 	 },	 
+ 	{
+ 	 .name = "All",
+ 	 .size = MTDPART_SIZ_FULL,	//32M
+ 	 .offset = 0x00000000,
+ 	 },
+ 	{
+ 	 .name = "APP_ORG",
+ 	 .size = 0x00500000,	//5M
+ 	 .offset = 0x00300000,
+ 	 },
+ 	{
+ 	 .name = "APP_BAK",
+ 	 .size = 0x00500000,	//5M
+ 	 .offset = 0x00800000,
+ 	 }	 	 	 
+ };
+ 
+ static struct physmap_flash_data physmap_flash_data = {
+ 	.width		= 2,
+ 	.set_vpp	= set_vpp,
+ 	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+ 	.parts		= mtd_parts_table
+ };
+ 
+ static int sat7111_phy_reset(void *bus)
+ {
+ 	stpio_set_pin(phy_reset_pio, 1);
+ 	udelay(1);
+ 	stpio_set_pin(phy_reset_pio, 0);
+ 	udelay(1);
+ 	stpio_set_pin(phy_reset_pio, 1);
+     
+ 	return 1;
+ }
+ 
+ static struct plat_stmmacphy_data phy_private_data = {
+ 	/* SMSC LAN 8700 */
+ 	.bus_id = 0,
+ 	.phy_addr = 0,
+ 	.phy_mask = 0,
+ 	.phy_reset = &sat7111_phy_reset,
+ 	.interface = PHY_INTERFACE_MODE_MII,
+ };
+ 
+ static struct platform_device sat7111_phy_device = {
+ 	.name		= "stmmacphy",
+ 	.id		= 0,
+ 	.num_resources	= 1,
+ 	.resource	= (struct resource[]) {
+ 		{
+ 			.name	= "phyirq",
+ 			.start	= -1,/*FIXME*/
+ 			.end	= -1,
+ 			.flags	= IORESOURCE_IRQ,
+ 		},
+ 	},
+ 	.dev = {
+ 		.platform_data = &phy_private_data,
+ 	}
+ };
+ 
+ static struct physmap_flash_data sat7111_physmap_flash_data = {
+ 	.width		= 2,
+ 	.set_vpp	= NULL,
+ 	.nr_parts	= ARRAY_SIZE(mtd_parts_table),
+ 	.parts		= mtd_parts_table
+ };
+ 
+ static struct platform_device physmap_flash = {
+ 	.name		= "physmap-flash",
+ 	.id		= -1,
+ 	.num_resources	= 1,
+ 	.resource	= (struct resource[]) {
+ 		{
+ 			.start		= 0x00000000,
+ 			.end		= 64*1024*1024 - 1,
+ 			.flags		= IORESOURCE_MEM,
+ 		}
+ 	},
+ 	.dev		= {
+ 		.platform_data	= &sat7111_physmap_flash_data,
+ 	},
+ };
+ 
+ /* J34 must be in the 1-2 position to enable NOR Flash */
+ static struct mtd_partition nand_partitions[] = {
+ 	{
+ 		.name	= "NAND root",
+ 		.offset	= 0,
+ 		.size 	= 0x00800000
+ 	}, {
+ 		.name	= "NAND home",
+ 		.offset	= MTDPART_OFS_APPEND,
+ 		.size	= MTDPART_SIZ_FULL
+ 	},
+ };
+ 
+ static struct plat_stmnand_data sat7111_nand_config = {
+ 	.emi_bank		= 0,
+ 	.emi_withinbankoffset	= 0,
+ 
+ 	/* Timings for NAND512W3A */
+ 	.emi_timing_data = &(struct emi_timing_data) {
+ 		.rd_cycle_time	= 40,		 /* times in ns */
+ 		.rd_oee_start	= 0,
+ 		.rd_oee_end	= 10,
+ 		.rd_latchpoint	= 10,
+ 		.busreleasetime = 0,
+ 
+ 		.wr_cycle_time	= 40,
+ 		.wr_oee_start	= 0,
+ 		.wr_oee_end	= 10,
+ 
+ 		.wait_active_low = 0,
+ 	},
+ 
+ 	.chip_delay		= 40,		/* time in us */
+ 	.mtd_parts		= nand_partitions,
+ 	.nr_parts		= ARRAY_SIZE(nand_partitions),
+ };
+ 
+ static struct platform_device *sat7111_devices[] __initdata = {
+ //	&sat7111_leds,
+ #ifdef FLASH_NOR
+ 	&physmap_flash,
+ #endif
+ 	&sat7111_phy_device,
+ //	&sat7111_button_device,
+ };
+ 
+ /* Configuration based on Futarque-RC signals train. */
+ lirc_scd_t lirc_scd = {
+ 	.code = 0x3FFFC028,
+ 	.codelen = 0x1e,
+ 	.alt_codelen = 0,
+ 	.nomtime = 0x1f4,
+ 	.noiserecov = 0,
+ };
+ 
+ static int __init device_init(void)
+ {
+ 	//stx7111_configure_pwm(&pwm_private_info);
+ 	stx7111_configure_ssc(&ssc_private_info);
+ 	stx7111_configure_usb(1); /* Enable inverter */
+ 	stx7111_configure_ethernet(1, 0, 0, 0);
+     	stx7111_configure_lirc(&lirc_scd);
+ 
+ 	vpp_pio = stpio_request_pin(3,6, "VPP", STPIO_OUT);
+     	phy_reset_pio = stpio_request_pin(4,4, "PHY", STPIO_OUT);
+      	usb_reset_pio = stpio_request_pin(3,5, "USB_RESET", STPIO_OUT);
+ 	stpio_set_pin(usb_reset_pio, 1);
+ 	udelay(1);
+ 	stpio_set_pin(usb_reset_pio, 0);
+ 	udelay(1);
+ 	stpio_set_pin(usb_reset_pio, 1);     
+ 
+ #ifndef FLASH_NOR
+ 	stx7111_configure_nand(&sat7111_nand_config);
+ 	/* The MTD NAND code doesn't understand the concept of VPP,
+ 	 * (or hardware write protect) so permanently enable it.
+ 	 */
+ 	stpio_set_pin(vpp_pio, 1);
+ #endif
+ 	stpio_set_pin(vpp_pio, 1);
+ 
+ 	return platform_add_devices(sat7111_devices, ARRAY_SIZE(sat7111_devices));
+ }
+ arch_initcall(device_init);
+ 
+ static void __iomem *sat7111_ioport_map(unsigned long port, unsigned int size)
+ {
+ 	/* However picking somewhere safe isn't as easy as you might think.
+ 	 * I used to use external ROM, but that can cause problems if you are
+ 	 * in the middle of updating Flash. So I'm now using the processor core
+ 	 * version register, which is guaranted to be available, and non-writable.
+ 	 */
+ 	return (void __iomem *)CCN_PVR;
+ }
+ 
+ static void __init sat7111_init_irq(void)
+ {
+ }
+ 
+ struct sh_machine_vector mv_sat7111 __initmv = {
+ 	.mv_name		= "sat7111",
+ 	.mv_setup		= sat7111_setup,
+ 	.mv_nr_irqs		= NR_IRQS,
+ 	.mv_init_irq		= sat7111_init_irq,
+ 	.mv_ioport_map		= sat7111_ioport_map,
+ };
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/kernel/cpu/sh4/setup-stx7111.c	2011-06-19 18:34:29.000000000 +0300
--- linux-sh4/arch/sh/kernel/cpu/sh4/setup-stx7111.c	2011-07-29 06:50:51.114192548 +0300
***************
*** 396,404 ****
--- 396,411 ----
  	STASC_DEVICE(0xfd032000, evt2irq(0x1120), 13, 17,
  		     4, 3, 2, 4, 5,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
+ #if 0 // change to pio 6.7 & 6.3		
  	STASC_DEVICE(0xfd033000, evt2irq(0x1100), 14, 18,
  		     5, 0, 1, 2, 3,
  		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
+ #else
+ 	/* ILC_FIRST_IRQ+ILC_EXT_IRQ+X, ILC_FIRST_IRQ=176, ILC_EXT_IRQ=64, X=34 */
+ 	STASC_DEVICE(0xfd034000, evt2irq(0x2440), 14, 18,
+ 		     6, 7, 3, 2, 6,
+ 		STPIO_ALT_OUT, STPIO_IN, STPIO_IN, STPIO_ALT_OUT),
+ #endif		
  };
  
  /*
***************
*** 429,435 ****
  		port = ascs[i] & 0xff;
  		flags = ascs[i] >> 8;
  		pdev = &stm_stasc_devices[port];
! 
  		switch (ascs[i]) {
  		case 0:
  			/* Route UART0 instead of PDES to pins.
--- 436,442 ----
  		port = ascs[i] & 0xff;
  		flags = ascs[i] >> 8;
  		pdev = &stm_stasc_devices[port];
! 		printk("stx7111_configure_asc[%d]  port[%d] \n",i,port);
  		switch (ascs[i]) {
  		case 0:
  			/* Route UART0 instead of PDES to pins.
***************
*** 495,500 ****
--- 502,508 ----
  		.dir  = STPIO_IN,
                  .pinof= 0x00 | LIRC_IR_RX | LIRC_PIO_ON
  	},
+ #if 0
  	[1] = {
  		.bank = 3,
  		.pin  = 4,
***************
*** 513,518 ****
--- 521,527 ----
  		.dir  = STPIO_ALT_OUT,
                  .pinof= 0x00 | LIRC_IR_TX | LIRC_PIO_ON
  	},
+ #endif	
  };
  
  static struct plat_lirc_data lirc_private_info = {
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/Kconfig	2011-06-19 18:34:29.000000000 +0300
--- /home/work/fortis/kconfig/Kconfig	2011-07-31 18:50:11.082161131 +0300
***************
*** 602,607 ****
--- 602,614 ----
  	  STB7111-MBOARD, ST board ID: mb618). More information at:
  	  <http://www.stlinux.com/boards/mb618/>
  
+ config SH_ST_SAT7111
+ 	bool "SAT7111: STi7111SAT Reference board"
+ 	depends on CPU_SUBTYPE_STX7111
+ 	help
+ 	  Select STi7111SAT Reference if configuring for an
+ 	  STMicroelectronics STi7111SAT Reference.
+ 
  config SH_ST_MB628
  	bool "mb628: STx7141 Mboard"
  	depends on CPU_SUBTYPE_STX7141
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/Makefile	2011-06-19 18:34:29.000000000 +0300
--- /home/work/fortis/kconfig/Makefile	2011-07-31 18:54:09.314161104 +0300
***************
*** 157,162 ****
--- 157,163 ----
  machdir-$(CONFIG_SH_ST_5197CAB)			+= st/5197cab
  machdir-$(CONFIG_SH_ST_MB837)			+= st/mb837
  machdir-$(CONFIG_SH_ST_MB839)			+= st/mb839
+ machdir-$(CONFIG_SH_ST_SAT7111)         += st/sat7111 st/common
  
  incdir-y	:= $(notdir $(firstword $(machdir-y)))
  
*** linux-sh4-2.6.23.17_stm23_0123_orig/drivers/char/tty_io.c	2007-10-09 22:31:38.000000000 +0200
--- linux-sh4/drivers/char/tty_io.c	2011-07-29 06:50:44.314192549 +0300
***************
*** 162,167 ****
--- 162,192 ----
  static void __proc_set_tty(struct task_struct *tsk, struct tty_struct *tty);
  static void proc_set_tty(struct task_struct *tsk, struct tty_struct *tty);
  
+ #define SIZE_DobleBuffer	512
+ 
+ /* { Chris - Simple Double Buffer - 2009Nov23  */
+ typedef enum
+ {
+ 	DBUF_Original,
+ 	DBUF_Second,
+ 	DBUF_All
+ } T_TtyDoubleBufferFlag;
+ 
+ #define	TIO_FORTIS_SELECT			(('f'<<8) | 0xf0 )	
+ #define	TIO_FORTIS_READ_SECOND	(('f'<<8) | 0xf1 )	
+ #define	TIO_FORTIS_RESET		(('f'<<8) | 0xf2 )	
+ 
+ #define	MAX_RD_IDX	32
+ typedef struct 
+ {
+ 	struct tty_struct tty;
+ 	unsigned char buf[SIZE_DobleBuffer];
+ 	int	tgid[MAX_RD_IDX];
+ 	int	rd[MAX_RD_IDX];
+ 	int	wr;
+ 	int	flag;	// 0 = use original, 1 = use second buffer only; 2 = use all buffer
+ } S_TtyDoubleBuffer;
+ /* Chris - Simple Double Buffer - 2009Nov23  } */
  /**
   *	alloc_tty_struct	-	allocate a tty object
   *
***************
*** 173,179 ****
  
  static struct tty_struct *alloc_tty_struct(void)
  {
! 	return kzalloc(sizeof(struct tty_struct), GFP_KERNEL);
  }
  
  static void tty_buffer_free_all(struct tty_struct *);
--- 198,220 ----
  
  static struct tty_struct *alloc_tty_struct(void)
  {
! 	/* { Chris - Simple Double Buffer - 2009Nov23  */
! 	S_TtyDoubleBuffer *tty;
! 
! 	tty = ( S_TtyDoubleBuffer * )kzalloc(sizeof(S_TtyDoubleBuffer), GFP_KERNEL);
! 	if (tty)
! 		memset(tty, 0, sizeof(S_TtyDoubleBuffer));
! 	return (struct tty_struct *)tty;
! 	/*  Chris - Simple Double Buffer - 2009Nov23  } */
! 	
! 	/*
! 	struct tty_struct *tty;
! 
! 	tty = kzalloc(sizeof(struct tty_struct), GFP_KERNEL);
! 	if (tty)
! 		memset(tty, 0, sizeof(struct tty_struct));
! 	return (tty_struct)tty;
! 	*/
  }
  
  static void tty_buffer_free_all(struct tty_struct *);
***************
*** 1717,1722 ****
--- 1758,1804 ----
  
  EXPORT_SYMBOL(start_tty);
  
+ /*	{ Chris - Simple Double Buffer - 2009Dec03	*/
+ static int found_rdIdx( S_TtyDoubleBuffer *ttyDbl )
+ {
+ 	int rdIdx = -1;
+ 	int blank = -1;
+ 
+ 	for( rdIdx = 0; rdIdx < MAX_RD_IDX; rdIdx++ )
+ 	{
+ 		if( ttyDbl->tgid[rdIdx] == 0 && blank == -1 )
+ 		{
+ 			blank = rdIdx;
+ 		}
+ 		if( ttyDbl->tgid[rdIdx] == current->tgid ) 
+ 		{
+ 			break;
+ 		}
+ 	}
+ 	
+ 	if( rdIdx == MAX_RD_IDX && blank != -1 )
+ 	{
+ 		rdIdx = blank;
+ 		ttyDbl->tgid[rdIdx] = current->tgid;
+ 	}
+ 
+ 	return rdIdx;
+ }
+ 
+ static void remove_rdIdx(  S_TtyDoubleBuffer *ttyDbl )
+ {
+ 	int rdIdx = -1;
+ 
+ 	for( rdIdx = 0; rdIdx < MAX_RD_IDX; rdIdx++ )
+ 	{
+ 		if( ttyDbl->tgid[rdIdx] == current->tgid ) 
+ 		{
+ 			ttyDbl->tgid[rdIdx] = 0;
+ 			break;
+ 		}
+ 	}
+ }
+ /*	Chris - Simple Double Buffer - 2009Dec03	 } */
  /**
   *	tty_read	-	read method for tty device files
   *	@file: pointer to tty file
***************
*** 1754,1760 ****
--- 1836,1875 ----
  	ld = tty_ldisc_ref_wait(tty);
  	lock_kernel();
  	if (ld->read)
+ 	{
+ 		/*	{ Chris - Simple Double Buffer - 2009Dec03  */
+ 		int rdIdx;
+ 		int blank = -1;
+ 		int pos;
+ 		S_TtyDoubleBuffer *ttyDbl = (S_TtyDoubleBuffer *)tty;
  		i = (ld->read)(tty,file,buf,count);
+ 
+ 		rdIdx = found_rdIdx( ttyDbl );
+ 
+ 		if( rdIdx != -1 )
+ 		{
+ 			pos = 0;
+ 			for( pos = 0; pos < i; pos++ )
+ 			{
+ 				copy_from_user( &ttyDbl->buf[ ttyDbl->wr ], &buf[pos], 1 );
+ 				ttyDbl->wr = (ttyDbl->wr + 1 ) % SIZE_DobleBuffer;
+ 				if( ttyDbl->wr == ttyDbl->rd[rdIdx] )
+ 				{
+ 					ttyDbl->rd[rdIdx] = (ttyDbl->rd[rdIdx] + 1 ) % SIZE_DobleBuffer;
+ 				}
+ 			}
+ 		}
+ 
+ 		if( ttyDbl->flag == DBUF_Second )
+ 		{
+ 			i = 0;
+ 		}
+ 		/*	Chris - Simple Double Buffer - 2009Dec03  } */
+ 
+ 		/*
+ 		i = (ld->read)(tty,file,buf,count);
+ 		*/
+ 	}
  	else
  		i = -EIO;
  	tty_ldisc_deref(ld);
***************
*** 2313,2318 ****
--- 2428,2439 ----
  	unsigned long flags;
  	
  	tty = (struct tty_struct *)filp->private_data;
+ 	/* { Chris - Simple Double Buffer - 2009Dec03  */
+ 	{
+ 		S_TtyDoubleBuffer *ttyDbl = (S_TtyDoubleBuffer *)tty;
+ 		remove_rdIdx( ttyDbl );
+ 	}
+ 	/* Chris - Simple Double Buffer - 2009Dec03  } */
  	if (tty_paranoia_check(tty, filp->f_path.dentry->d_inode, "release_dev"))
  		return;
  
***************
*** 3432,3437 ****
--- 3553,3608 ----
  		case TIOCMBIC:
  		case TIOCMBIS:
  			return tty_tiocmset(tty, file, cmd, p);
+ 		/* { Chris - Simple Double Buffer - 2009Dec03  */
+ 		case TIO_FORTIS_SELECT :
+ 			{
+ 				S_TtyDoubleBuffer *ttyDbl = (S_TtyDoubleBuffer *)tty;
+ 				ttyDbl->flag = arg;
+ 			}
+ 			return 1;
+ 
+ 		case TIO_FORTIS_READ_SECOND :
+ 			{
+ 				S_TtyDoubleBuffer *ttyDbl = (S_TtyDoubleBuffer *)tty;
+ 				unsigned char *buf = (unsigned char *)arg;
+ 				int ret = 0;
+ 				int rdIdx = found_rdIdx( ttyDbl );
+ 
+ 				if( rdIdx != -1 )
+ 				{
+ 					if( ttyDbl->flag != DBUF_Original )
+ 					{
+ 						if( (ttyDbl->wr) < (ttyDbl->rd[rdIdx]) )
+ 						{
+ 							int size = (SIZE_DobleBuffer) - (ttyDbl->rd[rdIdx]);
+ 							copy_to_user( buf, &(ttyDbl->buf[ ttyDbl->rd[rdIdx] ]), size );
+ 							ttyDbl->rd[rdIdx]  = (ttyDbl->rd[rdIdx]  + size ) % SIZE_DobleBuffer;
+ 							buf += size;
+ 							ret += size;
+ 						}
+ 						
+ 						if( (ttyDbl->wr) > (ttyDbl->rd[rdIdx]) )
+ 						{
+ 							int size = (ttyDbl->wr) - (ttyDbl->rd[rdIdx]);
+ 							copy_to_user( buf, &(ttyDbl->buf[ ttyDbl->rd[rdIdx] ]), size );
+ 							ttyDbl->rd[rdIdx]  = (ttyDbl->rd[rdIdx]  + size ) % SIZE_DobleBuffer;
+ 							ret += size;
+ 						}	
+ 					}
+ 				}
+ 				
+ 				return ret;
+ 			}
+ 
+ 		case TIO_FORTIS_RESET :
+ 			{
+ 				S_TtyDoubleBuffer *ttyDbl = (S_TtyDoubleBuffer *)tty;
+ 				int rdIdx = found_rdIdx( ttyDbl );
+ 				ttyDbl->rd[rdIdx] = 0;
+ 				ttyDbl->wr = 0;
+ 			}
+ 			return 1;
+ 		/* Chris - Simple Double Buffer - 2009Dec03  } */
  		case TCFLSH:
  			switch (arg) {
  			case TCIFLUSH:
*** linux-sh4-2.6.23.17_stm23_0123_orig/drivers/serial/stasc.c	2011-06-19 18:34:29.000000000 +0300
--- linux-sh4/drivers/serial/stasc.c	2011-07-29 06:50:48.147192548 +0300
***************
*** 276,282 ****
--- 276,286 ----
  asc_verify_port(struct uart_port *port, struct serial_struct *ser)
  {
  	/* No user changeable parameters */
+ #if 0	
  	return -EINVAL;
+ #endif	
+ // why???
+ 	return 0; // Amadeus 09.04.01 -EINVAL;
  }
  
  /*---------------------------------------------------------------------*/
***************
*** 600,605 ****
--- 604,611 ----
  	unsigned int ctrl_val;
  	unsigned long flags;
  
+ 	/* wait for end of current transmission */ 
+ 	while (!asc_tx_empty(port)){};
  	spin_lock_irqsave(&port->lock, flags);
  
  	/* read control register */
***************
*** 686,692 ****
  
  	if (ascport->platform_flags & STASC_FLAG_TXFIFO_BUG) {
  		if (status & ASC_STA_THE)
! 			return (FIFO_SIZE / 2) - 1;
  	} else {
  		if (status & ASC_STA_THE)
  			return FIFO_SIZE / 2;
--- 692,698 ----
  
  	if (ascport->platform_flags & STASC_FLAG_TXFIFO_BUG) {
  		if (status & ASC_STA_THE)
! 			return (FIFO_SIZE / 2);
  	} else {
  		if (status & ASC_STA_THE)
  			return FIFO_SIZE / 2;
*** linux-sh4-2.6.23.17_stm23_0123_orig/include/asm-sh/irq-ilc.h	2011-06-19 18:34:29.000000000 +0300
--- linux-sh4/include/asm-sh/irq-ilc.h	2011-07-31 22:33:41.203161130 +0300
***************
*** 39,45 ****
  #define ILC_IRQ(x)	(ILC_FIRST_IRQ + (x))
  #elif	defined(CONFIG_CPU_SUBTYPE_STX7111)
  #define ILC_FIRST_IRQ	176
! #define ILC_NR_IRQS	(64+33)
  #define ILC_INT_IRQ(x)	(ILC_FIRST_IRQ + (x))
  #define ILC_EXT_IRQ(x)	(ILC_FIRST_IRQ + 64 + (x))
  #define ILC_IRQ(x)	ILC_INT_IRQ(x)
--- 39,45 ----
  #define ILC_IRQ(x)	(ILC_FIRST_IRQ + (x))
  #elif	defined(CONFIG_CPU_SUBTYPE_STX7111)
  #define ILC_FIRST_IRQ	176
! #define ILC_NR_IRQS	(64+35)
  #define ILC_INT_IRQ(x)	(ILC_FIRST_IRQ + (x))
  #define ILC_EXT_IRQ(x)	(ILC_FIRST_IRQ + 64 + (x))
  #define ILC_IRQ(x)	ILC_INT_IRQ(x)
*** linux-sh4-2.6.23.17_stm23_0123_orig/arch/sh/kernel/traps.c	2011-06-19 18:34:28.000000000 +0300
--- linux-sh4/arch/sh/kernel/traps.c	2011-08-03 23:58:46.680278483 +0300
***************
*** 655,665 ****
  			goto uspace_segv;
  
  		/* shout about userspace fixups */
! 		if ((se_usermode & 1) && !(test_thread_flag (TIF_UAC_NOPRINT)))
  			printk("Unaligned userspace access "
  			       "in \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
  			       current->comm,current->pid,
! 			       (u16*)regs->pc,instruction);
  #endif
  
  		if (se_usermode & 2)
--- 655,665 ----
  			goto uspace_segv;
  
  		/* shout about userspace fixups */
! 		/*if ((se_usermode & 1) && !(test_thread_flag (TIF_UAC_NOPRINT)))
  			printk("Unaligned userspace access "
  			       "in \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
  			       current->comm,current->pid,
! 			       (u16*)regs->pc,instruction);*/
  #endif
  
  		if (se_usermode & 2)
***************
*** 705,715 ****
  	} else {
  		se_sys += 1;
  
! 		if (se_kernmode_warn)
  			printk("Unaligned kernel access "
  			       "on behalf of \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
  			       current->comm,current->pid,(u16*)regs->pc,
! 			       instruction);
  
  		if (regs->pc & 1)
  			die("unaligned program counter", regs, error_code);
--- 705,715 ----
  	} else {
  		se_sys += 1;
  
! 		/*if (se_kernmode_warn)
  			printk("Unaligned kernel access "
  			       "on behalf of \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
  			       current->comm,current->pid,(u16*)regs->pc,
! 			       instruction);*/
  
  		if (regs->pc & 1)
  			die("unaligned program counter", regs, error_code);
